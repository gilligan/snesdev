                               A 65816 Primer

       [----------------------------------------------------------]

No republication or redistribution of the following is permitted without
the authors express written consent.

Table of Contents

  ------------------------------------------------------------------------

     i    Preface
     1.00 Introduction
     2.00 New 65816 Instructions
     3.00 65816 Native Mode Programming Model
     3.01    Native Mode Processor Status Register
     3.10 Native Mode Registers
     3.11    Accumulator:
     3.12    X,Y Index Registers
     3.13    Direct Page Register (D)
     3.14    Stack Pointer (S)
     3.15    Program Bank Register (PBR)
     3.16    Data Bank Register (DBR)
     3.20    Status Register
     3.21       Emulation Bit E: Hidden Bit
     3.22       Sixteen BIT User Registers
     3.23       Index Register Select
     3.24       Accumulator/Memory Select
     3.30    Setting Status Register Bits
     4.00 65816 Emulation Mode Programming Model
     4.10    Emulation Mode Registers
     5.00 Relocating the Stack and Direct Page
     6.00 Addressing Modes
     6.10       New 65816 Specific Addressing Modes
     6.20       Addressing Mode Descriptions
     7.00 Interrupts
     7.10      Hardware Vectors

     Appendix A: 65816 Instruction Set
     Appendix B: Composite Instruction List
     Appendix C: IC Pinouts

Disclaimer:

Some of the following information was referenced with various documents and
public documentation available for the Apple IIGS computer system and the
Super NES game console system via the world wide web and other user group
publications. No claim is made or intended against any copyrighted
information that may be contained within this document. The main
sub-content that could be construed as a copyright infringement, would be
the usage of mnemonic tables and the similarity of programming models.
Although these tables were built specifically for this project, it is
unclear what the legal status of mnemonic information is at present. Brett
Tabke 1997

This document is intended to aid those programming the 65816 Processor from
The Western Design Center. This chip is the basis for the Apple IIGS, the
Creative Micro Designs SuperCPU addon cartridge for the Commodore 64 & 128,
and the Super NES game console that are all based around the 65816 micro
processor.

  ------------------------------------------------------------------------

Preface

This document was pulled from several chapters of book project I had
started. I'd intended to publish a small booklet on programming the CMD
Super CPU cartridge detailing the operation of the 65816 - however, I have
been unable to acquire a release to republish some critical information.
So, the following is a few chapters that I feel are worthy of public
disclosure and distribution.

HTML Conversion Notes

This document was originally in IBM CG/ANSI format and the conversion to
HTML was marginal. Even with the file being fairly generic text, four
different browsers rendered it differently. Lynx 2.7 and Lynx 2.6 will not
render it the same - I tried to strike a happy medium - your mileage may
vary.

TOC
                               [ Image Jet ]

  ------------------------------------------------------------------------

1.00 Introduction
-----------------

Welcome to the world of 65816 programming. The 65816 is an advanced upgrade
to the vintage 6502 Central Processing Unit. The main new features include
full 24 bit addressing for direct memory access of up to 16 megabytes.
Additionally, the 65816 offers full 6502 emulation, new addressing modes,
full 16 bit user registers, and dozens of new instructions.

If you have been a 6502 programmer for long, the advantages of the 65816
will become clear very quick. Regardless of CPU operating speed (mhz) a the
65816 will operate a bit faster simply by the nature of the 16 bit user
registers. By using 16 bit registers for operations such as addition and
subtraction the 65816 also offers the programmer a substantial speed
increase.

The following document is not meant as a definitive guide to programming
the 65816, but rather a primer for those who are familiar with the 6502 and
wish to find the new 65816 (good) stuff.

The 65816 offers two primary modes of operation, Native 65816 Mode and 6502
emulation mode. The default power-up status of the processor is in 6502
emulation mode. Other than correcting a few bugs in the 6502, emulation
mode "looks and feels" just like a 6502.

There are a few notable differences between the 65816's emulation mode and
the original 6502. The 6502 opcodes that were unimplemented, are now
available as additional instructions on the 65816, thus they will not
produce the results they do on a stock NMOS 6502 CPU. The 65816 implements
ALL of the available 256 opcodes, whether in emulation or Native mode.

Also different between a 6502 and emulation mode is that the indirect jump
JMP ($XXXX) bug that caused the processor to retrieve the wrong data when
the low byte was $xx has been fixed.

While in emulation mode, the 65816's Direct (zero) Page register is set for
zero. The Stack pointer high byte is set for one (just as a 6502). The
Program and Data Bank Registers are initialized to zero. Timing of all
instructions is identical.

While in Native mode, the processor has full access to the 16 megabyte
address space via 24 bit addressing. Native mode also makes available
several new and extended processor registers. The 65816 has the ability to
relocate the Stack and Zero Page any where within the first 64k bank of
memory. For old Commodore 128 programmers, this will sound suspiciously
like the 128's Memory Management Units ability to relocate zero page and
the stack also - so it will be old hat from the start. (On a side note, it
will be interesting to program on CMD's Super CPU 128 - which will give you
a Relocatable Relocatable Zero Page and Stack. hmmm ;)

Native mode also opens up the world of 16 bit user registers. The
accumulator may be 8 or 16 bits and the XY index registers may also be 8 or
16 bits. The accumulator maybe seen in terms of two 8 bit registers with
one accessible and the other hidden, or as a full 16 bit register. While
the accumulator is set for 16 bits, memory is also treated in 16 bit (2
byte) fashion.

Two other new registers are the Data Bank Register and the Program Bank
register. The Program Bank Register functionally extends the program
counter out to 24 bits, while the Data Bank register allows code flow
control to branch or jump to points outside of the 6502's 64k address
space.

Lastly, while in Native mode the status register of the 65816 includes
several new bits. The old BRK bit is no longer needed as the 65816 has a
BRK hardware vector. The BRK bit is now replaced with the X bit to select
either 8 or 16 bit index registers. However while in emulation mode, the
BRK bit is still there. The old "reserved" bit 5 of the status register is
replaced with the 16/8 bit accumulator/memory select bit. There is also a
hidden emulation bit that is only accessible by exchanging it will the
carry flag.

Here is a run down of some of the new fun stuff:

   * XYA registers can be 16 or 8 bits wide.
   * Wow, two actual Block Move Memory instructions.
   * New push/pull instructions phx,plx,phy,ply.
   * New xfer instructions tyx,txy.
   * Set or Reset any memory bit without loading the accumulator.
   * INC and DEC the accumulator.
   * JSR indirect, Branch Always, or Branch Long to 64k.
   * Zero Page has been renamed to Direct Page. Like many strange things,
     this will be totally confusing at first. The only thing you can do is,
     "get over it and get on with it".

TOC

2.00 New 65816 Instructions:
----------------------------

There are some new instructions worthy of short detail:

New transfer instructions include:

     TXY,TYX xfer between x and y.
     TCD,TCD xfer between the accumulator and direct page pointer(D).
     TCS,TSC xfer between the accumulator and stack pointer(S).
     XBA     exchange the low 8 bits (a) and the high 8 bits
                    of the accumulator.
     XCE     exchange the contents of the emulation bit (E) with
                    the contents of the carry flag (C).

New Stack pushes and pulls:

     PHX,PHY,PLX,PLY  push and pull the XY index registers.
     PHB,PLB     to push/pull the data bank register.
     PHK         to push the program bank register (no pull present)
     PHD,PLD     to push/pull the direct page register.
     PEA         to push effect absolute address.
     PEI         to push effective indirect address.
     PER         to push effective relative address.

   Misc:
     MVN   Move block in negative direction.
     MVP   Move block in positive direction.
     STZ   Store a zero to any location.
     BRA   Branch always.
     BRL   Branch to any address in bank 0 (64k).
     RTL   Return Long. Pulls one more byte. (pc bank byte)

As you can see, there is plenty new to digest. The remainder of this
document will assume prior 6502 knowledge. Lets go.
TOC

  ------------------------------------------------------------------------

==========================================
3.00 65816 Native Mode Programming Model
==========================================
  ------------------------------------------------------------------------

Bits:23                          15                    7                 0
                                 /--------------------l-------------------\
                                 IAccumulator (B) (A or C) Accumulator (A)I
                                 \--------------------I-------------------/
     /--------------------------\
     I Data Bank Register (DBR) I
     \--------------------------/
                                 /--------------------l-------------------\
                                 I           X Index  I Register (X)      I
                                 \--------------------I-------------------/
                                 /--------------------l-------------------\
                                 I           Y Index  I Register (Y)      I
                                 \--------------------I-------------------/
      ---------------------------/--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I             Direct I Page Pointer (D)  I
      ---------------------------\--------------------I-------------------/
      ---------------------------/--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I             Stack  I Pointer (S)       I
      ---------------------------\--------------------I-------------------/
     /---------------------------l--------------------l-------------------\
     IProgram Bank Register(PBR) I            Program I Counter (PC)      I
     \---------------------------I--------------------I-------------------/

===================================
3.01 Processor Status Register (P)
===================================

Bits  7   6   5   4   3   2   1   0
                                /---\
                                I e --- Emulation 0 = Native Mode
    /---l---l---l---l---l---l---+---I
    I n I v I m I x I d I i I z I c I
    \-l-I-l-I-l-I-l-I-l-I-l-I-l-I-l-/
      I   I   I   I   I   I   I   \-------- Carry 1 = Carry
      I   I   I   I   I   I   \------------- Zero 1 = Result Zero
      I   I   I   I   I   \---------- IRQ Disable 1 = Disabled
      I   I   I   I   \------------- Decimal Mode 1 = Decimal, 0 = Binary
      I   I   I   \-------- Index Register Select 1 = 8-bit, 0 = 16-bit
      I   I   \-------- Memory/Accumulator Select 1 = 8-bit, 0 = 16 bit
      I   \----------------------------- Overflow 1 = Overflow
      \--------------------------------- Negative 1 = Negative

65816 Native Mode Programming Model

TOC

======================================
3.10 Native Mode Registers
======================================

3.11 Accumulator
-----------------

Although shown as a 16 bit register, it may be either 16 or 8 depending on
the status of bit 5 (memory/accumulator select) of the status register bit
designated M.

When in 8 bit mode (M=1) then the accessible low order 8 bit accumulator is
designated as A and the hidden but exchangeable is designated B. When in
full 16 bit accumulator mode (M=0) then the accumulator is designated as C.

3.12 X,Y Index Registers
-------------------------

The X and Y index registers are 8 or 16 bit selectable. When status
register bit 4 designated X is set to 1 then 8 bit registers are selected.
When set to 0 then 16 bit registers are selected.

TOC

3.13 Direct Page Register (D)
------------------------------

This register is formerly known as Zero Page. The Direct Page pointer
specifies where in the first bank of 64k Direct Page (zero page) will be
located. The Direct Page may be moved to ANY location within Bank 0.

The Bank byte (bits 16-23) is shown in a dashed line to represent the fact
that the Direct Page is always located within bank 0.

3.14 Stack Pointer (S):
-----------------------

Like the Direct (zero) Page Pointer, the Stack is now totally relocatable
within Bank 0 (first 64k) of memory. The Bank byte (bits 16-23) is shown in
a dashed line to represent the fact that the Stack is always located within
bank 0. While in Native Mode the stack is not restricted to 256 bytes in
length.
while in emulation mode (e=1) the stack is located at page 1.

TOC

3.15 Program Bank Register (PBR):
---------------------------------

Much like the DBR below, the Program Bank Register is used to specify
address's above and beyond the 6502 64k limit. The PBR is referred to as
the Bank Byte or the highest 8 bits of the Program Counter. Flow control
instructions such as JSR and JMP, may jump to full 23 bit address's. The
PBR is used to specify the highest order 8 bits of the effective address.
However; relative branches do not roll out of the current bank. Branch
commands that branch across $FFFF roll back into the current bank. Also;
program segments may not cross bank boundaries - the program counter goes
from $FFFF to $0000 during such and occurrence.

3.16 Data Bank Register (DBR):
------------------------------

Certain addressing modes take advantage of the 65816's ability to address
up to 16meg of data. Those modes that retrieve and store data to absolute
16 meg/(24 bit address's use the DBR as the top 8 bits of the effective
address. The DBR is also referred to as the Data Bank Byte. The term Bank
Byte is used so that High Byte still refers to bits 8-15 of a given
location or register.

When indexed addressing mode branch across 64k bank boundaries, DBR is
temporarily incremented.

TOC

3.20 Status Register
=====================

The status register bits 7,6,3,2,1,0 (nvdizc) function the same as the 6502
status register bits.

The B break bit is no longer needed to detect a BRK. Instead a new hardware
vector has been implemented to direct code flow to a OS ROM handler in the
same way as an IRQ. However, while in emulation mode (E=1) BRK and the B
bit work as a 6502 does.

3.21 Emulation Bit E: Hidden Bit
--------------------------------

The emulation status bit E specifies whether the processor is in 6502
emulation mode or Native 65816 mode. 1=emulation. The processor powers up
in default 6502 emulation mode. When in 6502 emulation mode, the processor
is functionally a 6502. With the exceptions of un implemented opcodes, all
other opcodes perform identically to their true 6502 counter parts. In
emulation mode, the stack is defined as page one, direct page is defined as
page zero, and the Data Bank and Program Bank bytes are set to zero. The
additional 65816 opcodes are also available in emulation mode.

The emulation status bit is a hidden or phantom bit that is not directly
set, tested, or cleared. Therefore, a new instruction is used to exchange
the values of the carry bit and the emulation bit (XCE:eXchange Carry with
emulation bit). After exchanging, the carry can be tested to determine the
previous status of the E bit.

    To switch to Native Mode use the following:

        clc    ;clear carry to zero.

        xce    ;exchange (swap) carry with the emulation bit.

    To return to Emulation mode:

        sec    ;set carry to one.
        xce    ;exchange (swap) carry with the emulation bit.

TOC

3.22 Sixteen BIT User Registers
--------------------------------

The main advantage of the 65816 over the 6502 is that the Accumulator and
the XY index registers can be toggle between 8 and 16 bits wide. The width
of the Accumulator and the XY registers are independently selectable. Thus
you may select any combination of either:

       16 bit accum. m=0  - 16 bit XY regs x=0
       16 bit accum. m=0  -  8 bit XY regs x=1
        8 bit accum. m=1  - 16 bit XY regs x=0
        8 bit accum. m=1  -  8 bit XY regs x=1

When the accumulator is switched from or to 16 bits, the high order byte is
retained in either direction.

When the XY registers are switched from 16 bits to 8 bits, the high byte
(bits 8-15) are lost. When switching the XY registers to 16 bits, the high
byte becomes a zero.

TOC

3.23 Status Bit 4 X: Index Register Select
-------------------------------------------

Bit 4 of the status register selects either 8 bit or 16 bit XY index
register operation. When x=1 (8 bit), the XY registers function identically
to the 6502 index registers.

When x=0 (16 bit), both the X and Y registers become 16 bits wide. All
operations involving the X and Y registers act on all 16 bits of the index
register.

When switching from 8 to 16 or 16 to 8 bit index register, the high byte of
either X or Y will be come zero.

While in emulation mode (E=1) bit 4 is the B BRK flag bit.

TOC

3.24 Status Bit 5: Accumulator/Memory Select
---------------------------------------------

Bit 5 specifies whether the accumulator will be treated as an 8 bit or 16
bit register. When in 16 bit mode (m=0) all operations involving the
accumulator will act upon 16 bits of data. Such as, when in 16 bit mode, a
standard load (lda $1000) will load the load by ($1000) in the low order 8
bits of the accumulator and load ($1001) into the high order of the
accumulator.

When switching the accumulator from 16 to 8 or from 8 to 16 bits, the high
byte is perfectly retained. While in 8 bit mode, the high byte of the
accumulator (B) maybe exchanged with the low byte with the XBA instruction.

While in emulation mode, bit 5 is not present.

TOC

3.30 Setting Status Register Bits
----------------------------------

Two new instructions have been added to 65816 Native mode to set and reset
bits of the status register. The two instructions are SEP (set processor
status bits) and REP (reset processor status bits). They both use a single
byte operand to specify which bits should be set or reset. For example to
set bit 4 of the status register to 1 for 8 bit registers:

          SEP  #%00010000   ;set bit 4.

Or to clear bit 4 for 16 bit XY index registers:

          REP #%00010000   ;reset (clear) bit 4.

You may set or reset more than 1 bit at a time. For example, to set both 16
bit accumulator/memory and 16 bit XY registers use the following:

          REP #%00110000   ;set 16 bit accum/xy registers.

  ------------------------------------------------------------------------

=============================================
4.00 65816 Emulation Mode Programming Model I
=============================================
  ------------------------------------------------------------------------

Bits:23                          15                    7                 0
                                  --------------------l-------------------\
                                 |Accumulator (B)    (C)   Accumulator (A)I
                                  --------------------I-------------------/
     /--------------------------\
     I Data Bank Register (DBR) I
     \--------------------------/
                                                      /-------------------\
                                                      I X Index Register  I
                                                      \-------------------/
                                                      /-------------------\
                                                      I Y Index Register  I
                                                      \-------------------/
      ---------------------------l--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I             Direct I Page Pointer (D)  I
      ---------------------------I--------------------I-------------------/
      ---------------------------l--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I    0 0 0 0 0 0 0 1 I Stack Pointer (S) I
      ---------------------------I--------------------I-------------------/
     /---------------------------l--------------------l-------------------\
     IProgram Bank Register(PBR) I            Program I Counter (PC)      I
     \---------------------------I--------------------I-------------------/

4.10 Emulation Mode Registers

=============================

TOC

Emulation Mode Processor Status Register (P)
--------------------------------------------

Bits  7   6   5   4   3   2   1   0
                                /---\
                                I e --- Emulation 1 = 6502 Emulation Mode
    /---l---l---l---l---l---l---+---I
    I n I v I   I b I d I i I z I c I
    \-l-I-l-I---I-l-I-l-I-l-I-l-I-l-/
      I   I       I   I   I   I   \-------- Carry 1 = Carry
      I   I       I   I   I   \------------- Zero 1 = Result Zero
      I   I       I   I   \---------- IRQ Disable 1 = Disabled
      I   I       I   \------------- Decimal Mode 1 = Decimal, 0 = Binary
      I   I       \------------ Break Instruction 1 = BRK caused IRQ
      I   I
      I   \----------------------------- Overflow 1 = Overflow
      \--------------------------------- Negative 1 = Negative

              65816 Emulation Mode Programming Model.

TOC

The above 6502 emulation mode Programming Model shows some interesting
features of the 65816 while in emulation mode. Even though 16 bit index
registers are not available in emulation mode, you can still do the
following:

   * Relocate Direct Page.
   * Use the stack addressing modes.
   * Swap the lower A accumulator with the hidden B accumulator.
   * The Program and Data Bank Registers can be changed.
   * Use the new instructions.

Things lost or changed in Emulation mode verses Native mode:

   * The ability to use 16 bit user registers. The M and X bits of the
     status register are returned to their 6502 form.
   * The utility of the Block Move instructions. Block Move instructions
     use the index registers to specify the source and destination
     address's of a move - with only 8 bits available in emulation mode,
     you can only move data within zero page because the high byte will
     always be zero.
   * Zero page addressing "wraps" in emulation mode, whereas in Native mode
     it rolls into the next page.
   * The stack pointer is ALWAYS on page one.

When switching from emulation to native mode the processor replaces the B
BREAK flag and bit 5 with the 65816 M and X flags, and sets them to one.
This leaves the index registers and accumulator/memory into 8 bit mode
(which is the same as emulation mode). The remaining bits in the status
register are unchanged. The stack pointer remains at page one.

When switching from native mode into emulation mode; the M and X status
register bit disappear, putting the accumulator and index registers at 8
bit. The X and Y low bytes are retained, but the high bytes are lost. The
accumulator low and high bytes are retained. (of course the high byte is
hidden but accessible with the XBA instruction). The stack pointer is
returned to eights bits with the high byte forced to one and the high byte
is lost.

I think that after you work with the 65816 in emulation mode you will
realize that it is not about what you lose over native mode, but how much
you gain over a 6502. The fact that all of the extra opcodes and
instructions are still available even in emulation mode, makes for a
powerful processor even without the 16 bit registers.

  ------------------------------------------------------------------------

TOC

5.00 Relocating the Stack and Direct Page:
------------------------------------------

On power-up, the Stack is set to page one and the direct page (Zero Page)
to page zero. When in emulation mode (E=1) the Stack is initialized to Page
one, and Zero page is initialized to Page zero to emulate the default
status of the 6502.

Relocating the Direct Page (formerly known as Zero Page) is accomplished by
use of the PLD:pull direct page instruction.

        LDA #$5900   ; lda with immediate 16 bit data.
        PHA          ; on the stack with 16 bits.
        PLD          ; pull it back into the direct page register.

Always keep in mind that PLD pulls 16 bits (2 bytes) off the stack. You may
also use the TCD:transfer C register to Direct page register. (the C
register refers to the Accumulator as 16 bits)



        LDA #$5900   ; load 16 bit accum with immediate 16 bit data.
        TCD          ; transfer accum to direct page register.

Although you generally will want to keep Direct Page starting on an even
256 page boundary (low byte zero), you can specify a low byte address at
any 1-255 value. However all of the Direct Page (zero page) addressing
modes will add one clock cycle to the execution time if the low byte of the
direct page register is other than zero.

While in emulation mode, a direct page addressing mode where the index
rolls out of direct page will wrap around to the beginning of the direct
page, just as a 6502 does. For example:

      LDX #$2C

      LDA ($E0,X)

Would yield an effective address of $0C and not $10C.

While in Native mode, a direct page addressing mode where the index rolls
out of direct page will wrap into the next page of memory. Using the
example from above would yield the expected $10C effect address.

For those old Commodore 128 programmers, the concept of a relocatable
Direct Page is nothing new - we've been tweaking it on the MMU for years.
However; relocating zero page to something other than a page boundary has
some strong implications for the right style of code.

The power behind changing the direct page, is the same as 6502 zero page
addressing has always been. You can save bytes by using direct page
addressing (zero page) modes and acquire faster execution times as well. It
will take some time to find the best ways to program with a relocated
direct page, but once mastered, you wont get along with out.

TOC

  ------------------------------------------------------------------------

  ------------------------------------------------------------------------

=======================
6.00 Addressing Modes
=======================

All 6502 and 65C02 addressing modes and opcodes are supported in 65816
Native mode. Nine other new addressing modes are also supported in both
emulation and Native mode. However; there are a few notable addressing
differences between 816 Native mode and its 6502 counter part.

While in emulation mode there is no page wraparound when using Zero Page
Indexed addressing from a base address+index that "rolls over" $FF. While
in Native 65816 mode indexes can be 16 bits, so if the base address+index
rolls over into the next page the proper effective address in generated.
With 16 bit index registers, a direct page addressing mode where indexing
rolls over $FFFF the effective address roll back into the current bank not
into the next bank (ie:lda $20,x where x is $FFFF will result in an
effective address of $1F).

When using absolute indexed addressing where the base address is $FF01 to
$FFFF an index value that would cause the eFFective address to roll over
$FFFF would result in the next ram bank being accessed. Whereas on a 6502
there would be a wrap around into zero page.

Remember that when index registers are 16 bit, that absolute indexed X or
absolute indexed Y can now reach up to a full 64k! (ie: lda $6000,y where
y=$2000 would result in an effective address of $8000).

The 85618 also fixed the 6502 indirect JMP bug. A JMP ($12FF) now yields
the proper address of $12FF-$1300.

TOC

6.10 New 65816 Specific Addressing Modes:
-----------------------------------------
        New Mode Name                             Example
        -------------------------------------------------------
        Program Counter Relative Long             BRL $1234
        Stack Relative                            LDA 15,S
        Stack Relative Indirect Indexed Y         LDA (9,S),Y
        Block Move                                MVP 0,0
        Absolute Long                             LDA $123456
        Absolute Long Indexed X                   LDA $123456,X
        Absolute Indexed Indirect                 JMP ($1234,X)
        Absolute Indirect Long                    JMP [$1234]
        Direct Page Indirect                      LDA ($12)
        Direct Page Indirect Long                 LDA [$12]
        Direct Page Indirect Long Indexed Y       LDA [$77],Y

6.20 Addressing Mode Descriptions

----------------------------------

Program Counter Relative Long: BRL #$44

Program Counter Relative Long extends the range of the branch instructions
from the standard -127/+128 to 64k (+32767/-32768). Thus; the operand of
the BRL branch command is 16 bits. This address mode will help enormously
when writing relocatable code.

Stack Relative: LDA 7,S

Stack Relative addressing uses the Stack Pointer as a base address and then
adds the one byte user supplied operand as an offset into the stack. The S
specifies that this mode is Stack addressing via the stack pointer.

When using Stack Relative Addressing you should keep in mind that the Stack
Pointer will always point to the NEXT available spot on the stack. Thus, an
operand of one will retrieve the last item pushed onto the stack. An
operand of zero maybe useful to get another copy of the last thing PULLED
off the stack - but, of course, if an interrupt hits, then you would be in
trouble as the stack is manipulated via the interrupt routine.

Stack Relative Indirect Indexed Y: LDA ($22,S),Y

This addressing mode, locates and indirect address that points to the base
data located elsewhere (same as zero page indirect indexed). This two byte
instruction starts with the current location of the stack, then adds the
first operand, and finally adds in the Y index as and offset.

The value of this addressing mode is that suppose you have an address you
pushed onto the stack, by using this mode you can easily reach to where the
data was located.

                10   LDY #0

                20   LDA (1,S),Y   ; get the address 16 bits

                30   TAX           ; save it in x

                40   LDY #2

                50   LDA (1,S),Y   ; get a second address



In the example above, we start with the current stack pointer location as
the base address. In line 20 we load from an offset of one (1,S) and then
add in the offset to give the effective address. The above assumes we are
in 16 bit index and 16 bit accumulator mode.

     Block Move:                               MVP 0,0

This is a major new addressing mode used by two instructions on the 65816.
The two new instructions Block Move Positive and Block Move Negative can
move up to 64K of data from one memory location to another. To setup a
move, the accumulator is loaded with the number of bytes to copy, the X
register is loaded with source address, and the Y register holds the
destination address. Then issue the Block move instruction and data is
moved at 7 cycles per byte.

     Absolute Long:                            LDA $123456

Absolute Long is used to locate any data within the 16 bit address space of
the 65816. The operand is three bytes (24 bits long). The main usage of
this addressing mode is to temporarily override the contents of the DBR
Data Bank Register for the execution of the single instruction. If standard
absolute addressing is used, then the bank byte is concatenated to the
address from the DBR.



 Absolute Long Indexed X: LDA $123456,X

Absolute Long Indexed starts with the base operand and then adds the X
index value to create an effective address. This is the same as 6502
Absolute Indexed X, except the base operand is 24 bits wide. Note that the
actual order of bytes is Opcode, low byte, high byte, bank byte and that it
is up to the assembler to arrange the bytes in this order.

 Absolute Indexed Indirect JMP ($1234,X)

Absolute Indexed Indirect is a three byte instruction that creates the
effective address by starting with the specified operand and then adding in
the index value. Old 6502 programmers will recognize the following command
lookup and execute example:

               SEC
               SBC "0"        ; subtract ascii zero off accumulator.
               ASL            ; times two into a table.
               TAX            ; into x as offset into word table.
               LDA TABLE,X    ; get command address byte.
               STA PTR        ; save in indirect pointer.
               LDA TABLE+1,X  ; get table command address high byte.
               STA PTR+1      ; save in pointer high byte.
               JMP (PTR)      ; jump to command.

               TABLE .WORD RUT1,RUT2,RUT3,...
               PTR   .BYTE 0,0

Using Absolute Indexed Indirect addressing it could be written in half the
bytes and cycles:

               SEC
               SBC "0"        ; subtract ascii zero off accumulator.
               ASL            ; times two into a table.
               TAX            ; into x as index into word table.
               JMP (TABLE,X)  ; jump to command.

               TABLE .WORD RUT1,RUT2,RUT3,...

A JMP Indexed Indirect [JMP ($1234,x)] assumes that the operand address is
in the current program bank. A JMP indirect [JMP ($1234)] assumes that the
operand address is in BANK ZERO.

     Absolute Indirect Long                    JMP [$1234]

This addressing mode will form and effective address from the location
pointed to by the operand.

     Direct Page Indirect                       LDA ($12)

This instruction is two bytes long. The operand points to a 16 bit Direct
Page (zero page) pointer that will form the effective address. For example,
if the Direct Page pointer is $70, then the low byte with come from $70,
and the high byte from $71, and the Bank Byte from $72. The bank byte will
be the current data bank register.

     Direct Page Indirect Long                 LDA [$12]

This instruction is two bytes long. The operand points to a 24 bit Direct
Page (zero page) pointer that will form the effective address. For example,
if the Direct Page pointer is $70, then the low byte with come from $70,
the high byte from $71, and the Bank Byte from $72. The bank byte will
temporarily override the data bank register.

     Direct Page Indirect Long Indexed Y       LDA [$77],Y

This instruction in two bytes long and allows you to temporarily reach into
any memory bank. The operand is a direct page (zero page) pointer. The
address located at the direct page offset is three bytes long. First is the
low byte, then high byte, followed by the bank byte of the base effect
address. The Y index register is then added to this three byte destination
address to form the effective address. Square brackets are used to denote
that the address is a full 24 bit address and not a simple 16 bit address.

TOC

  ------------------------------------------------------------------------

7.00 Interrupts
---------------


There are some quirks to 65816 interrupts that you should consider. If you
are going to be writing native 65816 code you should give some
consideration to how your interrupt routine is going to be handled. If you
have written custom a IRQ routine that assumes Native mode, then your
considerations are minor. However, if you are writing Native mode 65816
code with 16 bit accumulator and/or 16 bit index registers, and you are
using a stock kernal IRQ that assumes emulation mode, then you must do some
coding to handle the discrepancies. In 6502 emulation mode, and IRQ pushes
the program counter high, then pc low, and finally the status register on
to the stack. When in Native mode an IRQ starts by stacking the following:

    Program Counter Bank (PBR)

    Program Counter High

    Program Counter Low

    Status Register

Next; the status register decimal mode bit (d) is cleared (setting binary
mode), and the IRQ flag is set (non NMI only). Finally, the program bank
(PBR) is set to zero and the 65816 jumps through the IRQ hardware vector.

The implications are that if the 65816 is running in emulation mode in a
ram bank other than Bank zero, then the program bank is going to be lost
(not good). There are two solutions to the problem. One is never to run in
emulation mode outside of Ram Bank zero. Second; you could save off the
current program bank value somewhere in Ram before running in emulation
mode beyond Bank Zero.

One thing that is unclear at this point, is if the CMD Super CPU can even
handle a Native Mode IRQ. Native Mode features a new hardware vector table:

TOC

7.10 Hardware Vectors:
----------------------
     Native Mode           6502 Emulation Mode
     -----------------------------------------
     IRQ   $FFEE-$FFEF     IRQ/BRK $FFFE-$FFFF
                           RESET   $FFFC-$FFFD
     NMI   $FFEA-$FFEB     NMI     $FFFA-$FFFB
     ABORT $FFE8-$FFE9     ABORT   $FFF8-$FFF9
     BRK   $FFE6-$FFE7
     COP   $FFE5-$FFE6     COP     $FFF4-$FFF5


Notice that there is a separate BRK vector for Native mode, and no need to
poll bit 5 for the brk flag. However when running in emulation mode,
remember that bit 5 is still the BRK flag, and your IRQ will still need to
check for the source of the IRQ.

While in Native mode, a BRK instruction is two bytes. The Zero BRK opcode
followed by an optional "signature" byte. This way, you can detect what BRK
caused the vector to be taken for multiple BRK's while debugging.

COP is for a coprocessor interrupt. (see the instruction COP)

Notice in Native mode where the IRQ vector destinations are...hmm

When an IRQ is triggered, the current instruction is completed before the
interrupt is processed. This "interrupt latency" may be up to 7 clock
cycles. If you are running a time critical IRQ you may want to examine the
WAI:wait for interrupt instruction whereby you can stop the processor until
and interrupt occurs.

The ABORT vector listed above is taken when the 65816's Abort pin is pulled
low. This pin is only available on the 65816.

TOC

  ------------------------------------------------------------------------

  ------------------------------------------------------------------------

================================
Appendix A: 65816 Instruction Set

================================
  ------------------------------------------------------------------------
  ------------------------------------------------------------------------

Syntax Conventions:

   addr              two byte address.
   addr/const        two byte value: either an address or a constant.
   const             one- or two-byte constant.
   destbk            64k bank to which string will be moved.
   dp                one-byte direct page offset (6502 zero page).
   label             label of code in same 64K bank as instruction.
   long              three-byte address (includes bank byte)
   nearlabel         label of code close enough to instruction to be
                     reachable by a one-byte signed offset.
   sr                one-byte stack relative offset.
   srcebk            64k bank from which string will be moved.

   Flags
   Bits         76543210
                nvmxdizc
                       e

                n - negative.
                v - overflow.
                m - 8/16 memory/accumulator.
                x - 8/16 bit index registers.
                d - decimal mode.
                i - irq enable disable.
                z - zero result.
                c - carry.
                e - emulation.
  ------------------------------------------------------------------------

ADC  Add with carry.

When using 16 bit accumulator mode, as expected, a carry will be properly
rolled over from bit 7 to bit 8 when generated by the operation. (ie: $FF+4
= $0103 with 1 in high byte an 3 in low byte of the accumulator.) Thus
carry need only be cleared when the low order bytes are added. Manual
checking for carry above bit 15 will still have to be done just as when in
8 bit accumulator mode.

When in 16 bit mode, the low-order bits are located in the effective
address, and the high order bits are located in the effective address plus
one.

     Flags Altered nv----zc
                   n Set if most-significant bit of result is set.
                   v Set if signed overflow.
                   z Set if result is zero.
                   c Set if overflow.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                     ADC #const     69      2*      2 | 1
  Absolute                      ADC addr       6D      3       4 | 1
  Absolute Long                 ADC long       6F      4       5 | 1
  Direct Page                   ADC dp         65      2       3 | 1,2
  Direct Page Indirect          ADC (dp)       72      2       5 | 1,2
  Direct Page Indirect Long     ADC [dp]       67      2       6 | 1,2
  Absolute Indexed,X            ADC addr,X     7D      3       4 | 1,3
  Absolute Long Indexed,X       ADC long,X     7F      4       5 | 1
  Absolute Indexed,Y            ADC addr,Y     79      3       4 | 1,3
  Direct Page Indexed,X         ADC dp,X       75      2       4 | 1,2
  DP Indexed Indirect,X         ADC (dp,X)     61      2       6 | 1,2
  DP Indirect Indexed,Y         ADC (dp),Y     71      2       5 | 1,2,3
  DP Indirect Long Indexed,Y    ADC [dp],Y     77      2       6 | 1,2
  Stack Relative                ADC sr,S       63      2       4 | 1
  SR Indirect Indexed,Y         ADC (sr,S),Y   73      2       7 | 1
-----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is <>0.
  3 Add 1 cycle if adding index crosses a page boundary.

AND And Accumulator with Memory

    Logically ANDs the data located at the effective address
    specified by the operand and the accumulator.
    If in 16 bit accumulator mode (m=0) Data ANDed from memory is
    16 bits wide, the low byte is the effective address and the high
    byte is the effective address+1.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result of and is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    AND #const     29      2*      2 | 1
  Absolute                     AND addr       2D      3       4 | 1
  Absolute Long                AND long       2F      4       5 | 1
  Direct Page                  AND dp         25      2       3 | 1,2
  Direct Page Indirect         AND (dp)       32      2       5 | 1,2
  DP Indirect Long             AND [dp]       27      2       6 | 1,2
  Absolute Indexed,X           AND addr,X     3D      3       4 | 1,3
  Absolute Long Indexed,X      AND long,X     3F      4       5 | 1
  Absolute Indexed,Y           AND addr,Y     39      3       4 | 1,3
  Direct Page Indexed,X        AND dp,X       35      2       4 | 1,2
  DP Indexed Indirect,X        AND (dp,X)     21      2       6 | 1,2
  DP Indirect Indexed,Y        AND (dp),Y     31      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   AND [dp],Y     37      2       6 | 1,2
  Stack Relative (SR)          AND sr,S       23      2       4 | 1
  SR Indirect Indexed,Y        AND (sr,S),Y   33      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is <>0.
   3 Add 1 cycle if adding index crosses a page boundary.

ASL Arithmetic Shift Left

    Shifts all bits left with most significant bit moving into the
    carry flag.  If in 16 bit accumulator mode (m=0), data shifted
    is 16 bits.

     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c High bit (7 or 15) is moved into carry.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  ASL a          0A      1       2 |
  Absolute                     ASL addr       0E      3       6 | 1
  Direct Page                  ASL dp         06      2       5 | 1,2
  Absolute Indexed,X           ASL addr,X     1E      3       7 | 1
  Direct Page Indexed,X        ASL dp,X       16      2       6 | 1,2
----------------------------------------------------------------------
   1 Add 2 cycles if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is <>0.

TOC

Branching Instructions:
-----------------------

The following branch instructions work identically to a 6502 - therefore,
no indepth discussion will be presented.
Branching commands do not affect any status register flags. The single byte
operand range is +128 to -127.

        BCC Branch Carry Clear     alias BLT Branch Less Than.
        BCS Branch Carry Set       alias BGE Branch Greater Than or Equal.
        BEQ Branch Equal
        BNE Branch Not Equal
        BMI Branch Result Minus
        BPL Branch Result Positive
        BVC Branch Overflow Clear
        BVS Branch Overflow Set

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Program Counter Relative     BCC near       90      2       2 | 1,2
  Program Counter Relative     BCS near       B0      2       2 | 1,2
  Program Counter Relative     BEQ near       F0      2       2 | 1,2
  Program Counter Relative     BNE near       D0      2       2 | 1,2
  Program Counter Relative     BMI near       30      2       2 | 1,2
  Program Counter Relative     BPL near       10      2       2 | 1,2
  Program Counter Relative     BVC near       50      2       2 | 1,2
  Program Counter Relative     BVS near       70      2       2 | 1,2
----------------------------------------------------------------------
   1 Add 1 cycle if branch is taken.
   2 Add 1 more cycle if in 6502 emulation mode (e=1).

TOC

New Branch Instructions:
------------------------

BRA Branch Always

Branch always takes the operand branch without regard for the current state
of the status register. The single byte operand range is +128 to -127. This
instruction and the following BRL instruction ease the task of writing
relocatable code.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Program Counter Relative     BRA near       80      2       3 | 1
----------------------------------------------------------------------
    2 Add 1 more cycle if in 6502 emulation mode (e=1).

BRL   Branch Always Long

Same as BRA, but the operand is 2 bytes giving the instruction a 64k range.
This instruction is similar to the JMP command, with the advantage being
that JMP is and absolute address and BRL is a relative address.
No flags are affected.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
-----------------------------------------------------------------
  Program Counter Relative Long BRL $xxxx     82      3       4
-----------------------------------------------------------------

BIT  Test Memory Bits against Accumulator

The 65816 provides 3 new addressing modes for the old standard BIT
instruction. The only true difference is that when the processor is in 16
bit mode, the top two bits xfered to the status register will come from
bits 14 and 15. When in 8 bit mode bits 6 and 7 are xfered to the status
register.

     Flags affected nv----z-  (Other than immediate addressing).
                    ------z-  (Immediate addressing only).
                    n Takes value of most significant bit of memory data.
                    v Takes value from bit 6 or 14 of memory data.
                    z Set if logical AND of mem and acc is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    BIT #const     89      2*      2 | 1
  Absolute                     BIT addr       2C      3       4 | 1
  Direct Page                  BIT dp         24      2       3 | 1,2
  Absolute Indexed,X           BIT addr,X     3C      3       4 | 1,3
  Direct Page Indexed,X        BIT dp,X       34      2       4 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is <>0.
  3 Add 1 cycle if adding index crosses a page boundary.

BRK Software Break

While in native 65816 mode, BRK is unaffected by the I interrupt disable
flag. Additionally, you may now pass a one byte signature byte to indicate
which BRK instruction caused the BRK to be preformed.
The new BRK handler includes a Hardware Vector- thus, it is no longer
required to check for the BRK bit flag via the IRQ.

When a BRK is performed in 65816 Native mode:


   * the program counter bank register is pushed onto stack.

   * the program counter is incremented by two and pushed on the stack.

   * the status register is pushed onto the stack

   * the interrupt disable flag is set.

   * the decimal mode flag is cleared.

   * the program bank register is cleared to zero.

   * the program counter is loaded from the break vector at $FFE6-$FFE7.

While in 6502 emulation mode, (e=1) a BRK is preformed true to it's 6502
forerunner (b flag set, status pushed onto stack, SEI and IRQ performed.).

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack/Interrupt              BRK            00      2*      7 | 1
----------------------------------------------------------------------
  * BRK is one byte, but program counter value pushed onto stack is
    incremented by 2 allowing for optional signature byte.
  1 Add one cycle for 65816 native mode (e=0).

Status Register Setting and Clearing:
-------------------------------------

The following status set and reset instructions operate the same in 65816
native mode and 6502 emulation mode.

      CLC  Clear carry flag.
      CLD  Clear decimal flag.
      CLI  Clear interrupt flag.
      CLV  Clear overflow flag.
      SEC  Set carry flag.
      SED  Set decimal flag.
      SEI  Set interrupt flag.

                 Flags
Addressing Mode nvmxdizc     Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied       -------0      CLC            18      1       2
  Implied       ----0---      CLD            D8      1       2
  Implied       -----0--      CLI            58      1       2
  Implied       -0------      CLV            B8      1       2
  Implied       -------1      SEC            38      1       2
  Implied       ----1---      SED            F8      1       2
  Implied       -----1--      SEI            78      1       2
----------------------------------------------------------------------

TOC

CMP Compare Accumulator with Memory

For the most part, this instruction works the same in 6502 emulation mode
and 65816 mode.
While in 16 bit accumulator mode the low byte of the compare will come from
the effective address and the high byte from the effective address plus
one.

     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c Set if no borrow was required. Acc => memory.
                     C=0 if borrow required Acc < memory.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    CMP #const     C9      2*      2 | 1
  Absolute                     CMP addr       CD      3       4 | 1
  Absolute Long                CMP long       CF      4       5 | 1
  Direct Page                  CMP dp         C5      2       3 | 1,2
  Direct Page Indirect         CMP (dp)       D2      2       5 | 1,2
  Direct Page Indirect Long    CMP [dp]       C7      2       6 | 1,2
  Absolute Indexed,X           CMP addr,X     DD      3       4 | 1,3
  Absolute Long Indexed,X      CMP long,X     DF      2       7 | 1
  Absolute Indexed,Y           CMP addr,Y     D9      3       4 | 1,3
  Direct Page Indexed,X        CMP dp,X       D5      2       4 | 1,2
  DP Indexed Indirect,X        CMP (dp,X)     C1      2       6 | 1,2
  DP Indirect Indexed,Y        CMP (dp),Y     D1      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   CMP [dp],Y     D7      2       6 | 1,2
  Stack Relative (SR)          CMP sr,S       C3      2       4 | 1
  SR Indirect Indexed,Y        CMP (sr,S),Y   D3      2       7 | 1
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is <>0.
  3 Add 1 cycle if adding index crosses a page boundary.

COP Coprocessor Empowerment

COP cause a software interrupt through a separate COP hardware vector. The
vector is to be located at $FFF$-$FFF5. In 6502 emulation mode:

   * The program counter is incremented by 2 and pushed on stack.
   * The status register is pushed onto the stack.
   * The interrupt status bit is set.
   * The program counter is loaded with the hardware vector.
   * The decimal flag is cleared.

In Native mode:

   * The PC bank register is pushed onto stack.
   * The PC is incremented by two and pushed onto stack.
   * The status register is pushed onto stack.
   * The interrupt status flag is set.
   * The program bank register is cleared to zero.
   * The PC is loaded with the hardware vector.
   * The decimal flag is cleared after COP executed.

     Flags Altered ----di--
                   d decimal mode flag is reset to zero.
                   i Interrupt disable is set.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack/Interrupt              COP const      02      2**     7 | 1
----------------------------------------------------------------------
  * COP is a 1 byte instruction, but the PC in incremented by to and
    pushed onto stack, allowing for an optional signature byte.
  1 Add 1 cycle for 65816/65802 native mode (e=0)

CPX Compare X Index register with Memory

CPX functions the same as a 6502. The only notable exception is to remember
that when in 16 bit index register mode (x=0) that date/memory will be 16
bits wide. The low order byte will come from the the effect address and the
high order byte from the effective address plus one.

     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c Set if no borrow was required ( X >= memory).
                     Cleared if borrow required (X < memory).

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    CPX #const     E0      2*      2 | 1
  Absolute                     CPX addr       EC      3       4 | 1
  Direct Page                  CPX dp         E4      2       3 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit index registers).
  1 Add 1 cycle if x=0 (16-bit index registers).
  2 Add 1 cycle if low byte of Direct Page register is <>0.

CPY Compare Y Index register with Memory

CPY functions the same as a 6502. The only notable exception is to remember
that when in 16 bit index register mode (x=0) that date/memory will be 16
bits wide. The low order byte will come from the the effect address and the
high order byte from the effective address plus one.

     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c Set if no borrow was required ( Y >= memory).
                     Cleared if borrow required (Y < memory).

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    CPY #const     C0      2*      2 | 1
  Absolute                     CPY addr       CC      3       4 | 1
  Direct Page                  CPY dp         C4      2       3 | 1,2
----------------------------------------------------------------------
    * Add 1 byte if m=0 (16-bit index registers).
    1 Add 1 cycle if x=0 (16-bit index registers).
    2 Add 1 cycle if low byte of Direct Page register is <> 0.

DEC Decrement Memory

DEC also works nearly the same as a 6502 mode. When in 16 bit
accumulator/memory mode (m=0) data altered will be 16 bits wide with
automatic underflow from high byte to low byte. The low order byte will
come from the the effect address and the high order byte from the effective
address plus one.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  DEC A          3A      1       2 |
                        Alias: DEA
  Absolute                     DEC addr       CE      3       6 | 1
  Direct Page                  DEC dp         C6      2       5 | 1,2
  Absolute Indexed,X           DEC addr,X     DE      3       7 | 1
  Direct Page Indexed,X        DEC dp,X       D6      2       6 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is <>0.

DEX, DEY Decrement Index Registers

Both instructions operate just as a 6502. When in 16 bit index register
mode, the register will be treated as 16 bits wide.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      DEX            CA      1       2
  Implied                      DEY            88      1       2
----------------------------------------------------------------------

EOR Exclusive-OR Accumulator with Memory

Another instruction that operates just as a 6502, only new addressing
modes. When in 16 bit memory/accumulator mode data is 16 bits wide - as
usual the low byte will come from the effective address and the high byte
from the effective address plus one.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    EOR #const     49      2*      2 | 1
  Absolute                     EOR addr       4D      3       4 | 1
  Absolute Long                EOR long       4F      4       5 | 1
  Direct Page                  EOR dp         45      2       3 | 1,2
  Direct Page Indirect         EOR (dp)       52      2       5 | 1,2
  Direct Page Indirect Long    EOR [dp]       47      2       6 | 1,2
  Absolute Indexed,X           EOR addr,X     5D      3       4 | 1,3
  Absolute Long Indexed,X      EOR long,X     5F      4       5 | 1
  Absolute Indexed,Y           EOR addr,Y     59      3       4 | 1,3
  Direct Page Indexed,X        EOR dp,X       55      2       4 | 1,2
  DP Indexed Indirect,X        EOR (dp,X)     41      2       6 | 1,2
  DP Indirect Indexed,Y        EOR (dp),Y     51      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   EOR [dp],Y     57      2       6 | 1,2
  Stack Relative (SR)          EOR sr,S       43      2       4 | 1
  SR Indirect Indexed,Y        EOR (sr,S),Y   53      2       7 | 7
----------------------------------------------------------------------
    * Add 1 byte if m=0 (16-bit memory/accumulator).
    1 Add 1 cycle if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is <>0.
    3 Add 1 cycle if adding index crosses a page boundary.

INC Increment Data

Also operates just as the 6502 INC instruction. When in 16 bit
memory/accumulator mode (m=0) data acted upon is 16 bits wide.
One new addressing mode is Accumulator addressing that will increment the
Accumulator.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  INC a          1A      1       2 |
                        Alias: INA
  Absolute                     INC addr       EE      3       6 | 1
  Direct Page                  INC dp         E6      2       5 | 1,2
  Absolute Indexed,X           INC addr,X     FE      3       7 | 1
  Direct Page Indexed,X        INC dp,X       F6      2       6 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is <>0.

INX, INY  Increment Index Registers

Both instructions operate just as a 6502. When in 16 bit index register
mode, the register will be treated as 16 bits wide.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Implied                      INX            E8      1       2 |
  Implied                      INY            C8      1       2 |
----------------------------------------------------------------------

JMP Jump to New Location

JMP transfers control to the operand address. If a long jump is executed
the program counter bank register is loaded with the third byte of the
target address.

The 65816 Designers also specify that an assembler could possibly use JML
in place of a JMP Long instruction, and also JML [adr] for Absolute
indirect long.

        Flags Affected:--------

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     JMP addr       4C      3       3 |
  Absolute Indirect            JMP (addr)     6C      3       5 | 1
  Absolute Indexed Indirect    JMP (addr,X)   7C      3       6 |
  Absolute Long                JMP long       5C      4       4 |
                        Alias: JML long
  Absolute Indirect Long       JMP [addr]     DC      3       6 |
                        Alias: JML [addr]
----------------------------------------------------------------------
    1 6502: If low byte of addr is $FF (ie: addr is $xxFF) yields
      incorrect result.

JSR, JSL Jump to Subroutine (gosub)

JSR works just as a 6502 with the new addressing modes available. If an
absolute address is coded by the assembler that is less than $FFFF then a
standard JSR is used, else if it is greater than $FFFF then absolute long
addressing is used. A standard JSR gosubs to the the routine in the current
program bank.

JSR can also use Indexed Indirect addressing. (see section on addressing
modes for an example.)

JML is a four byte instruction that will JSR to a subroutine located in any
bank. When executed the current program counter bank is pushed onto the
stack before the program counter high/low bytes.

         Flags Affected: --------

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Absolute Long                JSL long       22      4       8
                        Alais: JSR long
  Absolute                     JSR addr       20      3       6
  Absolute Indexed Indirect    JSR (addr,X)   FC      3       8
----------------------------------------------------------------------

LDA Load the Accumulator with Memory

LDA is nearly identical to the standard 6502 LDA instruction. New features
are the implementation of the new addressing modes. While the status
register is set for 16 bit memory/accumulator mode (m=0), data loaded is 16
bits wide with the load byte coming from the effective address and the high
byte of the accumulator coming from the effective address plus one.

     Flags affected n-----z-
                    n Takes value of most significant bit of memory data.
                    z Set if data loaded is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    LDA #const     A9      2*      2 | 1
  Absolute                     LDA addr       AD      3       4 | 1
  Absolute Long                LDA long       AF      4       5 | 1,2
  Direct Page                  LDA dp         A5      2       3 | 1,2
  Direct Page Indirect         LDA (dp)       B2      2       5 | 1,2
  Direct Page Indirect Long    LDA [dp]       A7      2       6 | 1,2
  Absolute Indexed,X           LDA addr,X     BD      3       4 | 1,3
  Absolute Long Indexed,X      LDA long,X     BF      4       5 | 1
  Absolute Indexed,Y           LDA addr,Y     B9      3       4 | 1,3
  Direct Page Indexed,X        LDA dp,X       B5      2       4 | 1,2
  DP Indexed Indirect,X        LDA (dp,X)     A1      2       6 | 1,2
  DP Indirect Indexed,Y        LDA (dp),Y     B1      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   LDA [dp],Y     B7      2       6 | 1,2
  Stack Relative (SR)          LDA sr,S       A3      2       4 | 1
  SR Indirect Indexed,Y        LDA (sr,S),Y   B3      2       7 | 1
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is <>0.
  3 Add 1 cycle if adding index crosses a page boundary.

LDX Load X Register from Memory

LDX is identical to a stock 6502.
The only new feature to remember is that when in 16 bit index register mode
(x=0) that data will be 16 bits wide. The X register low byte will come
from the effective address and the high byte from the effective address
plus one.

     Flags affected n-----z-
                    n Takes value of most significant bit of memory data.
                    z Set if data loaded is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    LDX #const     A2      2*      2 | 1
  Absolute                     LDX addr       AE      3       4 | 1
  Direct Page                  LDX dp         A6      2       3 | 1,2
  Absolute Indexed,Y           LDX addr,Y     BE      3       4 | 1,3
  DP Indexed,Y                 LDX dp,Y       B6      2       4 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit index registers).
  1 Add 1 cycle if x=0 (16-bit index registers).
  2 Add 1 cycle if low byte of Direct Page register is <>0.
  3 Add 1 cycle if indexing crosses page boundary.

LDY Load Y Register from Memory

LDY is identical to a stock 6502.
The only new diversion is to remember that when in 16 bit index register
mode (x=0) that data will be 16 bits wide. The Y register low byte will
come from the effective address and the high byte from the effective
address plus one.

     Flags affected n-----z-
                    n Takes value of most significant bit of memory data.
                    z Set if data loaded is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    LDY #const     A0      2*      2 | 1
  Absolute                     LDY addr       AC      3       4 | 1
  Direct Page                  LDY dp         A4      2       3 | 1,2
  Absolute Indexed,X           LDY addr,X     BC      3       4 | 1,3
  Direct Page Indexed,X        LDY dp,X       B4      2       4 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit index registers).
  1 Add 1 cycle if x=0 (16-bit index registers).
  2 Add 1 cycle if low byte of Direct Page register is <>0.
  3 Add 1 cycle if indexing crosses page boundary.

LSR Logical Shift Right.

Yet another instruction unchanged from the standard 6502 instruction set.
16 bit mode (m=0) data shifted will be 16 bits wide.

     Flags Altered n-----zc
                   n Cleared.
                   z Set if result is zero.
                   c Bit zero becomes new carry.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  LSR a          4A      1       2 |
  Absolute                     LSR addr       4E      3       6 | 1
  Direct Page                  LSR dp         46      2       5 | 1,2
  Absolute Indexed,X           LSR addr,X     5E      3       7 | 1
  Direct Page Indexed,X        LSR dp,X       56      2       6 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is <>0.

Block Move Instructions
=======================

MVP Move Positive destination > source
MVN Move Negative destination < source

This instruction is new 65816 only. MVN and MVP move data from memory
location to memory location without user intervention.

Two instructions are necessary so that as the data is being moved in a
negative direction it will not overwrite itself.

The source address for the move is taken from the X register. The
destination address for the move is taken for the Y register. The 16 bit
length of the move is taken from the Accumulator regardless of the m flag
setting. This value should be one less than the actual length of the move
(ie a=$0000 and one byte will be moved).

The two operand bytes specify the source bank of 64k and the destination
bank of 64k. The assembler order of the operand bytes is source,
destination - however, the actual binary output code will be the MVN or MVP
opcode followed byte the destination bank byte and the source bank byte.

MVN Move Negative is used when the source address is greater than the
destination address, or conversely when the destination range is lower than
the source range.

The MVN instruction uses the X and Y registers to denote the bottom
(beginning) address of the two memory segments to be moved. With MVN the
data is moved from the source in X to the destination in Y, then the X and
Y registers are are incremented and the accumulator decremented until the
accumulator underflows to $FFFF.

MVP Move Positive is used with the source address is less than the
destination, or conversely when the destination range is higher in memory
than the source range.

The MVP instruction uses the X and Y registers to denote the top address of
the two blocks of memory. The data is moved from the source in X to the
address in Y and then the XY and accumulator registers are decremented
until the accumulator underflows to $FFFF.

If the index registers are set for 8 bit mode (x=1) or the processor is set
for 6502 emulation mode, then the data moved will be in page zero only
because the high bytes will default to zero.

To reduce code length it is very easy to setup the move instructions in a
subroutine, then use dynamically modified code to exchange the MVN and MVP
opcodes on-the-fly.

Status register flags are NOT affect by the move instructions.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Block Move                   MVN src,dest   54      3      *
  Block Move                   MVP src,dest   44      3      *
----------------------------------------------------------------------
   * 7 cycles each byte moved.

TOC

NOP No Operation.

Same as 6502. No flags are affected with NOP.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      NOP            EA      1       2
----------------------------------------------------------------------

ORA OR Accumulator with Memory.

Same function as 6502 ORA with new addressing modes.
When in 16 bit memory/accumulator mode (m=0) data acted upon is 16 bits
wide. The low byte is the effective address and the high byte is the
effective address plus one.

    Flags Affected: n-----z-
                    n Set if most significant bit of result is set.
                    z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    ORA #const     09      2*      2 | 1
  Absolute                     ORA addr       0D      3       4 | 1
  Absolute Long                ORA long       0F      4       5 | 1
  Direct Page                  ORA dp         05      2       3 | 1,2
  Direct Page Indirect         ORA (dp)       12      2       5 | 1,2
  Direct Page Indirect Long    ORA [dp]       07      2       6 | 1,2
  Absolute Indexed,X           ORA addr,X     1D      3       4 | 1,3
  Absolute Long Indexed,X      ORA long,X     1F      4       5 | 1
  Absolute Indexed,Y           ORA addr,Y     19      3       4 | 1,3
  Direct Page Indexed,X        ORA dp,X       15      2       4 | 1,2
  DP Indexed Indirect,X        ORA (dp,X)     01      2       6 | 1,2
  DP Indirect Indexed,Y        ORA (dp),Y     11      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   ORA [dp],Y     17      2       6 | 1,2
  Stack Relative (SR)          ORA sr,S       03      2       4 | 1
  SR Indirect Indexed,Y        ORA (sr,S),Y   13      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is <>0.
   3 Add 1 cycle if adding index crosses a page boundary.

PEA Push Effective Absolute Address

PEA pushes the sixteen-bit operand onto the stack. The stack pointer is
decremented by two. No flags are affected. Unlike other instructions that
use similar assembler notations, PEA pushes the value of the operands onto
the stack, NOT the data located at an effective address. A more appropriate
name should have been to push Immediate data onto the stack - it is unclear
why this discrepancy exists.

    For example:

               PEA $1234

Pushes a #$12 and then a #$34 onto the stack.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (Absolute)             PEA addr      F4      3       5
----------------------------------------------------------------------

PEI Push Effective Indirect Address

This 65816 instruction pushes the address of the effective address onto the
stack. This instruction always pushes 16 bits of data onto the stack
without regard for the settings of the x and m status bits.

The address of the effective address plus one is pushed on the stack first
and then the address of the effective address is pushed on second.

For example: suppose $5678 is stored at location $21/$22 in standard low
byte/high byte format, then a

         PEI ($21)

would get the $5678 from $21/$22 and push it onto the stack.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack (Direct Page Indirect) PEI (dp)      D4       2       6 | 1
----------------------------------------------------------------------
   1 Add 1 cycle if low byte of direct page is <>0.

PER Push effective PC Relative Indirect Address

This instruction takes the program counter and adds the 16 bit operand and
pushes the resulting 16 bits onto the stack. The destination address must
be located within the current bank of 64k memory. The value of the program
counter used in the calculation is the address of the NEXT instruction
following the PER and two operand bytes.

The result high byte is pushed first, followed by the low byte of the
result.

Because this instruction uses a relative offset for the operand, it can aid
in writing relocatable code. One could envision pushing an unknown run-time
address onto the stack with PER and then pulling the address off to
determine the programs run time origin.

Another use of this instruction could be to push a return address onto the
stack for 6502 pha:pha:rts style coding

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (PC Relative Long)   PER label       62      3       6
----------------------------------------------------------------------

Push, Pull APXY Instructions

PHA,PHP,PLA,PLP are unchanged from their 6502 forerunners. The only notable
difference is that 16 bits will be pushed on when in accumulator/memory
(m=0) mode and a PHA or PLA is executed (PHP/PLP only operate on 8 bits).

New push and pull stack instructions include PHY,PLY,PHX,PLX. These four
new instructions push and pull the index registers on and off the stack.
When the status register is set to 16 bit index register mode (x=0), the
pull and push index registers will operate on 16 bits when the status
register x is set to 0.

Addressing Mode   Flags      Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (Push)   --------      PHA            48      1       3 | 1
  Stack (Push)   --------      PHP            08      1       3 |
  Stack (Push)   --------      PHX            DA      1       3 | 2
  Stack (Push)   --------      PHY            5A      1       3 | 2
  Stack (Pull)   n-----z-      PLA            68      1       4 | 1
  Stack (Pull)   nvmxdizc      PLP            28      1       4 |
  Stack (Pull)   n-----z-      PLX            FA      1       4 | 2
  Stack (Pull)   n-----z-      PLY            7A      1       4 | 2
----------------------------------------------------------------------
   1 Add 1 cycle if 16 bit accumulator/memory mode (m=0).
   2 Add 1 cycle if 16 bit index registers (x=0).

Push, Pull Bank Registers

PHB Pushes the 8 bit contents of the data bank register on the stack.

PHD Pushes the 16 bit contents of the direct page register on stack.
The high byte is pushed first, followed by the low byte.

PHK Pushes the 8 bit contents of the program bank register on stack.

PLB Pulls a byte off the stack into the data bank register. This is the
only instruction that can directly change the data bank register.

PLD Pulls a sixteen bit value off stack into the direct page register. The
low byte is pulled first, followed by the high byte.

Pulled Flags Affected by pull instructions:

             n Set if most significant bit of value pulled is set.
             z Set if value pulled is zero.

Addressing Mode   Flags      Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (Push)                 PHB            8B      1       3
  Stack (Push)                 PHD            0B      1       4
  Stack (Push)                 PHK            4B      1       3
  Stack (Pull)   n-----z-      PLB            AB      1       4
  Stack (Pull)   n-----z-      PLD            2B      1       5
----------------------------------------------------------------------

REP Reset Status Bits.

REP is a new 65816 instruction. When used, it will reset (clear) the bits
specified by the 1 byte immediate value.

For Example to clear bit 5 of the status register:

REP #%00100000 ;clear bit 5.

or to clear multiple bits:

REP #%10110000 ;clear 7,5 and 4.

Any combination is acceptable.

To set a bit, see SEP.

    Flags affected: nvmxdizc
                 All flags that have an operand bit set are cleared.
                 Other flags are not affected.

Addressing Mode               Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Immediate                    REP #const     C2      2       3
----------------------------------------------------------------------

ROL Rotate Memory or Accumulator Left

ROL works same as the 6502 ROL instruction.
When in 16 bit accumulator/memory mode (m=0) Data rotated is 16 bits wide
with the former bit 15 becoming the new carry. - the low-order bits are
located in the effective address, and the high order bits are located in
the effective address plus one.

    Flags affected: n-----zc
                    n Set if most significant bit of result is set.
                    z Set if result is zero.
                    c The high bit (7 or 15) becomes the new carry.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  ROL A          2A      1       2 |
  Absolute                     ROL addr       2E      3       6 | 1
  Direct Page                  ROL dp         26      2       5 | 1,2
  Absolute Indexed,X           ROL addr,X     3E      3       7 | 1
  Direct Page Indexed,X        ROL dp,X       36      2       6 | 1,2
----------------------------------------------------------------------
   1 Add 2 cycles if 16 bit memory accumulator mode (m=0).
   2 Add 1 cycle if direct page pointer is <>0.

ROR Rotate Memory or Accumulator Right.

Works as 6502 ROR expected.
When in 16 bit memory/accumulator mode (m=0) data rotated will be 16 bits
wide, plus the carry - the low-order bits are located in the effective
address, and the high order bits are located in the effective address plus
one.

    Flags affected: n-----zc
                    n Set if most significant bit of result is set.
                    z Set if result is zero.
                    c Low bit becomes the new carry.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  ROR a          6A      1       2 |
  Absolute                     ROR addr       6E      3       6 | 1
  Direct Page                  ROR dp         66      2       5 | 1,2
  Absolute Indexed,X           ROR addr,X     7E      3       7 | 1
  Direct Page Indexed,X        ROR dp,X       76      2       6 | 1,2
----------------------------------------------------------------------
   1 Add 2 cycles if 16 bit memory accumulator mode (m=0).
   2 Add 1 cycle if direct page pointer is <>0.

RTI Return from Interrupt

While in 6502 emulation mode (e=1) RTI is handled the same as a stock 6502.
While in native 65816 mode (e=0) RTI also pulls the program bank register
byte off of the stack. Since this extra byte is present, it is essential
that the RTI be executed in the same mode (e=?) that the processor was in
when the interrupt was executed.

    Flags Affected:  The status register is pulled from the stack,
                     therefore all flags are affected.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack (RTI)                  RTI            40      1       6 |  1
----------------------------------------------------------------------
  1 add 1 cycle if 65816 native mode.

RTL Return from Subroutine Long

RTL works similar to an RTS but it also pulls the program bank register off
of the stack. This instruction should be used in conjunction with the JSR
long instruction or by a setup routine that also pushes the program bank
onto the stack. RTL pulls 24 bits off of the stack. First the two bytes of
the program counter low/high are pulled and incremented, then the program
bank register is pulled.

No Flags are affected by RTL.

TOC

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (RTL)                  RTL            6B      1       6
----------------------------------------------------------------------

RTS Return from Subroutine

Same as the 6502 instruction. No flags are affected.

One interesting use of RTS is to push a return address on the stack and
then execute it via RTS. In order to use this type of coding the address
pushed onto the stack must be one less than the actual routine address
because when pulled back off, the processor automatically inc's the program
counter before continuing. While in Native mode with 16 bit
accumulator/memory set, this can easily be accomplished by:

          DEC A   ; dec 16 be accum. or DEA.
          PHA     ; push 16 bit return adr on stack.
          RTS     ; return to execute the instruction.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (RTS)                  RTS            60      1       6
----------------------------------------------------------------------

SBC Subtract from Accumulator

SBC also works just a a 6502. Again the only difference is a few new
addressing modes, and the fact that data maybe worked in a 16 bit
accumulator or 16 bit memory location.
SBC and ADC when used in 16 bit memory/accumulator mode greatly enhance the
overall utility of the 65816. A programmer can easily see how much faster
addition and subtraction routines could be performed while operating on 16
bits instead of 8.

     Flags Altered nv----zc
                   n Set if most-significant bit of result is set.
                   v Set if signed overflow.
                   z Set if result is zero.
                   c Set if unsigned borrow not required.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    SBC #const     E9      2*      2 | 1
  Absolute                     SBC addr       ED      3       4 | 1
  Absolute Long                SBC long       EF      4       5 | 1
  Direct Page                  SBC dp         E5      2       3 | 1,2
  Direct Page Indirect         SBC (dp)       F2      2       5 | 1,2
  Direct Page Indirect Long    SBC [dp]       E7      2       6 | 1,2
  Absolute Indexed,X           SBC addr,X     FD      3       4 | 1,3
  Absolute Long Indexed,X      SBC long,X     FF      4       5 | 1
  Absolute Indexed,Y           SBC addr,Y     F9      3       4 | 1,3
  Direct Page Indexed,X        SBC dp,X       F5      2       4 | 1,2
  DP Indexed Indirect,X        SBC (dp,X)     E1      2       6 | 1,2
  DP Indirect Indexed,Y        SBC (dp),Y     F1      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   SBC [dp],Y     F7      2       6 | 1,2
  Stack Relative (SR)          SBC sr,S       E3      2       4 | 1
  SR Indirect Indexed,Y        SBC (sr,S),Y   F3      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is <>0.
   3 Add 1 cycle if adding index crosses a page boundary.

SEP Set Status Bits

SEP is a new 65816 instruction. When used, it will set the bits specified
by the 1 byte immediate value.
This is the only means of setting the M and X status register bits.

    For Example to set bit 5 of the status register:

       SEP #%00100000   ;set bit 5.

       or to clear multiple bits:

       SEP #%10110000   ;set bits 7,5 and 4.

    Any combination is acceptable.

    To reset a bit, see REP.

    Flags affected: nvmxdizc
                 All flags that have an operand bit set are set.
                 Other flags are not affected.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Immediate                 SEP #const       E2      2       3
----------------------------------------------------------------------

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STA addr       8D      3       4 | 1
  Absolute Long                STA long       8F      4       5 | 1
  Direct Page                  STA dp         85      2       3 | 1,2
  Direct Page Indirect         STA (dp)       92      2       5 | 1,2
  Direct Page Indirect Long    STA [dp]       87      2       6 | 1,2
  Absolute Indexed,X           STA addr,X     9D      3       5 | 1
  Absolute Long Indexed,X      STA long,X     9F      4       5 | 1
  Absolute Indexed,Y           STA addr,Y     99      3       5 | 1
  Direct Page Indexed,X        STA dp,X       95      2       4 | 1,2
  DP Indexed Indirect,X        STA (dp,X)     81      2       6 | 1,2
  DP Indirect Indexed,Y        STA (dp),Y     91      2       6 | 1,2
  DP Indirect Long Indexed,Y   STA [dp],Y     97      2       6 | 1,2
  Stack Relative (SR)          STA sr,S       83      2       4 | 1
  SR Indirect Indexed,Y        STA (sr,S),Y   93      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is <>0.

STP Stop the Processor

STP shuts the processor down until a hardware reset. It is used in some
systems to put the processor to sleep and reduce power consumption. There
is a RESet B pin on some 65816 processors that allow for the usage of this
instruction.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      STP            DB      1       3
----------------------------------------------------------------------

STX Store X Register to Memory

Another the same as 6502 mode.
Only exception is that when set for 16 bit index registers (x=0) data
stored will be 16 bits wide. Low 8 bits of Y will be stored to the
effective address and the high byte to the effective address plus one.
No flags are affected by STX.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STX addr       8E      3       4 | 1
  Direct Page                  STX dp         86      2       3 | 1,2
  Direct Page Indexed,Y        STX dp,y       96      2       4 | 1,2
----------------------------------------------------------------------
  1 Add 1 cycle if 16 bit index registers (x=0)
  2 Add 1 more cycle if low byte of Direct Page is <>0.

STY Store Y Register to Memory

Same as 6502 mode.
Only exception is that when set for 16 bit index registers (x=0) data
stored will be 16 bits wide. Low 8 bits of Y will be stored to the
effective address and the high byte to the effective address plus one.
No flags are affected by STY.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STY addr       8C      3       4 | 1
  Direct Page                  STY dp         84      2       3 | 1,2
  Direct Page Indexed,X        STY dp,X       94      2       4 | 1,2
----------------------------------------------------------------------
  1 Add 1 cycle if 16 bit index registers (x=0)
  2 Add 1 more cycle if low byte of Direct Page is <>0.

STZ Store Zero byte to Memory

A new instruction of the 65816. STZ stores a zero byte to the destination
address. When in 8 bit accumulator/memory mode (m=1) one byte is stored at
the effective address. While in 16 bit memory/accumulator mode (m=0) a zero
is stored to the effective address and to the effective address plus one.
No flags are affected.

This instruction could be defined as a replacement for stock 6502 code as:

       lda #0
       sta $xxxx

The perky thing about STZ is that the accumulator is unchanged and the
status register is also unchanged.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STZ addr       9C      3       4 | 1
  Direct Page                  STZ dp         64      2       3 | 1,2
  Absolute Indexed,X           STZ addr,X     9E      3       5 | 1
  Direct Page Indexed,X        STZ dp,X       74      2       4 | 1,2
----------------------------------------------------------------------
   1 Add 1 cycle if 16 bit index registers (x=0)
   2 Add 1 more cycle if low byte of Direct Page is <>0.

Register Transfer Instructions:

TAX,TXA,TAY,TYA,TSX,TXS transfer instructions transfer bytes between the
processor registers.

     TAX: Transfer accumulator to X index register.
     TAY: Transfer accumulator to Y index register.
     TYA: Transfer Y index register to the accumulator.
     TXA: Transfer X index register to the accumulator.
     TSX: Transfer Stack pointer to the X index register.
     TXS: Transfer X index register to the Stack pointer.

Two new register transfer instructions are TXY to transfer directly from
the X register into the Y register and TYX to transfer from Y register to X
register.

Because the accumulator and index registers can be set for either 8 or 16
bits independently, the width of the transfer is determined by the
destination register. The following table shows the possible combinations:

   8 bit acc to  8 bit index regs. (m=1,x=1) 8 bits transferred.
   8 bit acc,to 16 bit index regs (m=1, x=0), 16 bits are transferred.
                The hidden high order accumulator byte becomes the
                X or Y high byte.
  16 bit index regs to 8 bit acc (m=1, x=0), 8 bits are transferred.
                The hidden high order accumulator byte is not
                affected and the previous values remain.
   8 bit index regs to 16 bit acc (m=0, x=1), Two bytes
                transferred with the high byte being zero.
  16 bit acc to 8 bit index regs (m=0, x=1),  Only the low byte of the
                accumulator is transferred to the index register.
  16 bit acc to 16 bit index regs (m=0, x=0) 16 bits transferred.

  16 bit stack pointer to 8 bit X register.  Only the low byte
                address is transferred.
   8 bit X reg to 16 bit stack pointer, sets stack high byte to zero.

      Flags Affected: n-----z-
                      n Set if most significant bit of transfer value
                        is set.
                      z Set if transferred value is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TAX            AA      1       2
  Implied                      TAY            A8      1       2
  Implied                      TXA            8A      1       2
  Implied                      TYA            98      1       2
  Implied                      TSX            BA      1       2
  Implied                      TXS            9A      1       2
  Implied                      TXY            9B      1       2
  Implied                      TYX            BB      1       2
----------------------------------------------------------------------

Direct Page Instructions:
=========================

Two new 65816 instructions are used to exchange data between the
accumulator and the Direct Page Register.

TCD Transfer Accumulator to Direct Page Register.
TDC Transfer Direct Page Register to Accumulator.

TCD transfers a 16 bit value from the accumulator into the direct (zero
page) pointer. A full 16 bits is transferred regardless of the 16/8 bit
setting (m) of the accumulator.
The C in TCD is used to specify that the accumulator is referenced as C
when it is 16 bits wide (low byte being A and high byte being B).
TDC transfers from the Direct Page register into the full 16 bit
accumulator without regard for the setting of status bit m.

Some assemblers also allow TAD or TDA for the mnemonics.

      Flags Affected: n-----z-
                      n Set if most significant bit of transfer value
                        is set.
                      z Set if transferred value is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TCD            5B      1       2
                        Alais: TAD
  Implied                      TDC            7B      1       2
                        Alais: TDA
----------------------------------------------------------------------

TCS Transfer Accumulator to Stack Pointer

TCS transfers a full 16 bits to the stack pointer without regard for the
setting of status bit m.
As with TCD and TDC the C in TCS refers to the accumulator as a full 16
bits.
The mnemonic TAS, transfer a to stack pointer, is used by some assemblers.
While in 6502 emulation mode only the eight-bit A accumulator value is
transferred because the stack is always located at page 1 on a 6502 TCS and
TXS are the only two instructions that alter the stack pointer register.

No flags are affected by TCS.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TCS            1B      1       2
                        Alais: TAS
----------------------------------------------------------------------

TSC Transfer Stack Pointer to Accumulator

TSC transfers a full 16 bits of the stack pointer to the 16 bit accumulator
without regard for the setting of status bit m.
As with TCD and TDC the C in TSC refers to the accumulator as a full 16
bits.
The mnemonic TSA, transfer a to stack pointer, is used by some assemblers.

While in 6502 emulation mode a one will be transferred to the hidden B
(upper 8 bits) accumulator because the stack is always located at page one
in 6502 mode.

      Flags Affected: n-----z-
                      n Set if most significant bit of transfer value
                        is set.
                      z Set if transferred value is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TSC            3B      1      2
                        Alais: TSA
----------------------------------------------------------------------

TRB Test and Reset Memory Bits
------------------------------

TRB performs a logical AND of the accumulator's compliment and the
effective address - data is then rewritten back to the specified address.
This clears each memory bit that has a corresponding bit set in the
accumulator, leaving all other memory bits unchanged.

To put it another way - TRB flips or inverts the accumulator value and then
AND's that value with memory operand and stores the result back to the
effective address.

While is 16 bit accumulator mode (m=0) data is operated on in the expected
16 bit fashion. The low byte of the operation is at the effective address
and the high byte at the effective address plus one.

       Flags Affected: ------z-
                       z Set if memory value AND'ed with accumulator
                       value is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     TRB addr       1C      3       6 | 1
  Direct Page                  TRB dp         14      2       5 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if 16 bit memory/accumulator mode (m=0)
    2 Add 1 cycle if direct page register low byte is <>0.

TSB Test and Set Memory Bits
----------------------------

TSB logically OR's the accumulator and the data at the effective address.
This effectively sets a bit at the memory location for each bit set in the
accumulator.

While is 16 bit accumulator mode (m=0) data is operated on in the expected
16 bit fashion. The low byte of the operation is at the effective address
and the high byte at the effective address plus one.

The status register zero flag is set after the accumulator is AND'd with
the memory value. (same as the BIT instruction).

       Flags Affected: ------z-
                       z Set if memory value AND'ed with accumulator
                       value is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     TSB addr       0C      3       6 | 1
  Direct Page                  TSB dp         04      2       5 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if 16 bit memory/accumulator mode (m=0)
    2 Add 1 cycle if direct page register low byte is <>0.

WAI Wait for Interrupt
----------------------

WAI suspends operations until and external hardware interrupt is generated.
Power consumption by the processor is also reduced. If the disable
interrupt flag (i=1) is set and an IRQ is pending before the execution of
the WAI, then the WAIT is terminated and execution continues with the next
instruction.

No flags are affected by WAI.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      WAI            CB      1       3
----------------------------------------------------------------------

WDM Reserved for Future Expansion
---------------------------------

WDM is the first byte of a multi-byte instruction set to be used in future
versions of the processor.
At current WDM is treated like a NOP no operation.
This instruction should NOT be used in current versions of the processor.
WDM: William D. Mensch, JR. (65816 designer).

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
                               WDM            42      2
----------------------------------------------------------------------

XBA Exchange B and A Accumulators
---------------------------------

XBA exchanges the low eight bits of the accumulator (A) with the high order
8 bits of the accumulator (B). This operation has no regard for the setting
of the status bit M.
This instruction will also work in 6502 emulation mode.

XBA can be used to save a temp copy of the low accumulator in the upper
accumulator. It is also good when in 16 bit mode to invert a low and high
byte value.

XBA is the only instruction that can access the upper 8 bits of the
accumulator in emulation mode.

Some assemblers will also accept SWA (swap) for a mnemonic.

      Flags Affected: n------z-
                      n Set if the most significant bit of the new
                        value in the low order 8 bits (A) of the
                        accumulator is set. (former bit 15)
                      z Set if new value of the lower order 8 bit
                        accumulator (A) is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      XBA            EB      1       3
                        Alais: SWA
----------------------------------------------------------------------

XCE Exchange Carry and Emulation Bits
-------------------------------------

XCE exchanges (swaps) the value in the E emulation bit and the C carry
flag. This is the only means to access the E emulation bit.

    To set emulation mode:
            sec  ;set carry.
            xce  ;exchange carry and emulation bits.

    To set native mode:
            clc  ;clear carry
            xce  ;exchange carry and e bit.

                            e
    Flags Affected --mx/b---c
                   e from previous carry flag.
                   c from previous emulation flag.
                   m native mode flag only. switching to native
                     65816 mode sets to one.
                   x x is a native mode flag only.
                   b brk is an emulation 6502 flag only. it is set
                     to 1 to become the x flag in native mode

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      XCE            FB      1       2
----------------------------------------------------------------------

TOC

  ------------------------------------------------------------------------

Appendix B:Composite Instruction List

  ------------------------------------------------------------------------

  ------------------------------------------------------------------------

Opcode Mnemonic  Addressing Mode              Bytes Cycles| Reference
=====================================================================
   00      BRK     Stack/Interrupt                2**     7 | 9
   01      ORA     DP Indexed Indirect,X          2       6 | 1,2
   02      COP     Stack/Interrupt                2**     7 | 9
   03      ORA     Stack Relative                 2       4 | 1
   04      TSB     Direct Page                    2       5 | 2,5
   05      ORA     Direct Page                    2       3 | 1,2
   06      ASL     Direct Page                    2       5 | 2,5
   07      ORA     Direct Page Indirect Long      2       6 | 1,2
   08      PHP     Stack (Push)                   1       3 |
   09      ORA     Immediate                      2*      2 | 1
   0A      ASL     Accumulator                    1       2 |
   0B      PHD     Stack (Push)                   1       4 |
   0C      TSB     Absolute                       3       6 | 5
   0D      ORA     Absolute                       3       4 | 1
   0E      ASL     Absolute                       3       6 | 5
   0F      ORA     Absolute Long                  4       5 | 1
   10      BPL     Program Counter Relative       2       2 | 7,8
   11      ORA     DP Indirect Indexed,Y          2       5 | 1,2,3
   12      ORA     Direct Page Indirect           2       5 | 1,2
   13      ORA     SR Indirect Indexed,Y          2       7 | 1
   14      TRB     Direct Page                    2       5 | 2,5
   15      ORA     Direct Page Indexed,X          2       4 | 1,2
   16      ASL     Direct Page Indexed,X          2       6 | 2,5
   17      ORA     DP Indirect Long Indexed,Y     2       6 | 1,2
   18      CLC     Implied                        1       2 |
   19      ORA     Absolute Indexed,Y             3       4 | 1,3
   1A      INC     Accumulator (INA)              1       2 |
   1B      TCS     Implied                        1       2 |
   1C      TRB     Absolute                       3       6 | 5
   1D      ORA     Absolute Indexed,X             3       4 | 1,3
   1E      ASL     Absolute Indexed,X             3       7 | 5,6
   1F      ORA     Absolute Long Indexed,X        4       5 | 1
   20      JSR     Absolute                       3       6 |
   21      AND     DP Indexed Indirect,X          2       6 | 1,2
   22      JSR     Absolute Long                  4       8 |
   23      AND     Stack Relative                 2       4 | 1
   24      BIT     Direct Page                    2       3 | 1,2
   25      AND     Direct Page                    2       3 | 1,2
   26      ROL     Direct Page                    2       5 | 2,5
   27      AND     Direct Page Indirect Long      2       6 | 1,2
   28      PLP     Stack (Pull)                   1       4 |
   29      AND     Immediate                      2*      2 | 1
   2A      ROL     Accumulator                    1       2 |
   2B      PLD     Stack (Pull)                   1       5 |
   2C      BIT     Absolute                       3       4 | 1
   2D      AND     Absolute                       3       4 | 1
   2E      ROL     Absolute                       3       6 | 5
   2F      AND     Absolute Long                  4       5 | 1
   30      BMI     Program Counter Relative       2       2 | 7,8
   31      AND     DP Indirect Indexed,Y          2       5 | 1,2,3
   32      AND     Direct Page Indirect           2       5 | 1,1
   33      AND     SR Indirect Indexed,Y          2       7 | 1
   34      BIT     Direct Page Indexed,X          2       4 | 1,2
   35      AND     Direct Page Indexed,X          2       4 | 1,2
   36      ROL     Direct Page Indexed,X          2       6 | 2,5
   37      AND     DP Indirect Long Indexed,Y     2       6 | 1,2
   38      SEC     Implied                        1       2 |
   39      AND     Absolute Indexed,Y             3       4 | 1,3
   3A      DEC     Accumulator                    1       2 |
   3B      TSC     Implied                        1       2 |
   3C      BIT     Absolute Indexed,X             3       4 | 1,3
   3D      AND     Absolute Indexed,X             3       4 | 1,3
   3E      ROL     Absolute Indexed,X             3       7 | 5,6
   3F      AND     Absolute Long Indexed,X        4       5 | 1
   40      RTI     Stack/RTI                      1       6 | 9
   41      EOR     DP Indexed Indirect,X          2       6 | 1,2
   42      WDM                                    2|16      |
   43      EOR     Stack Relative                 2       4 | 1
   44      MVP     Block Move                     3         | 13
   45      EOR     Direct Page                    2       3 | 1,2
   46      LSR     Direct Page                    2       5 | 2,5
   47      EOR     Direct Page Indirect Long      2       6 | 1,2
   48      PHA     Stack (Push)                   1       3 | 1
   49      EOR     Immediate                      2*      2 | 1
   4A      LSR     Accumulator                    1       2 |
   4B      PHK     Stack (Push)                   1       3 |
   4C      JMP     Absolute                       3       3 |
   4D      EOR     Absolute                       3       4 | 1
   4E      LSR     Absolute                       3       6 | 5
   4F      EOR     Absolute Long                  4       5 | 1
   50      BVC     Program Counter Relative       2       2 | 7,8
   51      EOR     DP Indirect Indexed,Y          2       5 | 1,2,3
   52      EOR     Direct Page Indirect           2       5 | 1,2
   53      EOR     SR Indirect Indexed,Y          2       7 | 1
   54      MVN     Block Move                     3         | 13
   55      EOR     Direct Page Indexed,X          2       4 | 1,2
   56      LSR     Direct Page Indexed,X          2       6 | 2,5
   57      EOR     DP Indirect Long Indexed,Y     2       6 | 1,2
   58      CLI     Implied                        1       2 |
   59      EOR     Absolute Indexed,Y             3       4 | 1,3
   5A      PHY     Stack (Push)                   1       3 | 10
   5B      TCD     Implied                        1       2 |
   5C      JMP     Absolute Long                  4       4 |
   5D      EOR     Absolute Indexed,X             3       4 | 1,3
   5E      LSR     Absolute Indexed,X             3       7 | 5,6
   5F      EOR     Absolute Long Indexed,X        4       5 | 1
   60      RTS     Stack (RTS)                    1       6 |
   61      ADC     DP Indexed Indirect,X          2       6 | 1,2,4
   62      PER     Stack (PC Relative Long)       3       6 |
   63      ADC     Stack Relative                 2       4 | 1,4
   64      STZ     Direct Page                    2       3 | 1,2
   65      ADC     Direct Page                    2       3 | 1,2,4
   66      ROR     Direct Page                    2       5 | 1
   67      ADC     Direct Page Indirect Long      2       6 | 1,4
   68      PLA     Stack (Pull)                   1       4 | 1
   69      ADC     Immediate                      2*      2 | 1,4
   6A      ROR     Accumulator                    1       2 |
   6B      RTL     Stack (RTL)                    1       6 |
   6C      JMP     Absolute Indirect              3       5 | 11,12
   6D      ADC     Absolute                       3       4 | 1,4
   6E      ROR     Absolute                       3       6 | 5
   6F      ADC     Absolute Long                  4       5 | 1,4
   70      BVS     Program Counter Relative       2       2 | 7,8
   71      ADC     DP Indirect Indexed,Y          2       5 | 1,2,3,4
   72      ADC     Direct Page Indirect           2       5 | 1,2,4
   73      ADC     SR Indirect Indexed,Y          2       7 | 1,4
   74      STZ     Direct Page Indexed,X          2       4 | 1,2
   75      ADC     Direct Page Indexed,X          2       4 | 1,2,4
   76      ROR     Direct Page Indexed,X          2       6 | 2,5
   77      ADC     DP Indirect Long Indexed,Y     2       6 | 1,2,4
   78      SEI     Implied                        1       2 |
   79      ADC     Absolute Indexed,Y             3       4 | 1,3,4
   7A      PLY     Stack (Pull)                   1       4 | 10
   7B      TDC     Implied                        1       2 |
   7C      JMP     Absolute Indexed Indirect      3       6 |
   7D      ADC     Absolute Indexed,X             3       4 | 1,3,4
   7E      ROR     Absolute Indexed,X             3       7 | 5,6
   7F      ADC     Absolute Long Indexed,X        4       5 | 1,4
   80      BRA     Program Counter Relative       2       3 | 8
   81      STA     DP Indexed Indirect,X          2       6 | 1,2
   82      BRL     Program Counter Relative Long  3       4 |
   83      STA     Stack Relative                 2       4 | 1
   84      STY     Direct Page                    2       3 | 2,10
   85      STA     Direct Page                    2       3 | 1,2
   86      STX     Direct Page                    2       3 | 2,10
   87      STA     Direct Page Indirect Long      2       6 | 1,2
   88      DEY     Implied                        1       2 |
   89      BIT     Immediate                      2*      2 | 1
   8A      TXA     Implied                        1       2 |
   8B      PHB     Stack (Push)                   1       3 |
   8C      STY     Absolute                       3       4 | 10
   8D      STA     Absolute                       3       4 | 1
   8E      STX     Absolute                       3       4 | 10
   8F      STA     Absolute Long                  4       5 | 1
   90      BCC     Program Counter Relative       2       2 | 7,8
   91      STA     DP Indirect Indexed,Y          2       6 | 1,2
   92      STA     Direct Page Indirect           2       5 | 1,2
   93      STA     SR Indirect Indexed,Y          2       7 | 1
   94      STY     Direct Page Indexed,X          2       4 | 2,10
   95      STA     Direct Page Indexed,X          2       4 | 1,2
   96      STX     Direct Page Indexed,Y          2       4 | 2,10
   97      STA     DP Indirect Long Indexed,Y     2       6 | 1,2
   98      TYA     Implied                        1       2 |
   99      STA     Absolute Indexed,Y             3       5 | 1
   9A      TXS     Implied                        1       2 |
   9B      TXY     Implied                        1       2 |
   9C      STZ     Absolute                       3       4 | 1
   9D      STA     Absolute Indexed,X             3       5 | 1
   9E      STZ     Absolute Indexed,X             3       5 | 1
   9F      STA     Absolute Long Indexed,X        4       5 | 1
   A0      LDY     Immediate                      2+      2 | 10
   A1      LDA     DP Indexed Indirect,X          2       6 | 1,2
   A2      LDX     Immediate                      2+      2 | 10
   A3      LDA     Stack Relative                 2       4 | 1
   A4      LDY     Direct Page                    2       3 | 2,10
   A5      LDA     Direct Page                    2       3 | 1,2
   A6      LDX     Direct Page                    2       3 | 2,10
   A7      LDA     Direct Page Indirect Long      2       6 | 1,2
   A8      TAY     Implied                        1       2 |
   A9      LDA     Immediate                      2*      2 | 1
   AA      TAX     Implied                        1       2 |
   AB      PLB     Stack (Pull)                   1       4 |
   AC      LDY     Absolute                       3       4 | 10
   AD      LDA     Absolute                       3       4 | 1
   AE      LDX     Absolute                       3       4 | 10
   AF      LDA     Absolute Long                  4       5 | 1
   B0      BCS     Program Counter Relative       2       2 | 7,8
   B1      LDA     DP Indirect Indexed,Y          2       5 | 1,2,3
   B2      LDA     Direct Page Indirect           2       5 | 1,2
   B3      LDA     SR Indirect Indexed,Y          2       7 | 1
   B4      LDY     Direct Page Indexed,X          2       4 | 2,10
   B5      LDA     Direct Page Indexed,X          2       4 | 1,2
   B6      LDX     DP Indexed,Y                   2       4 | 2,10
   B7      LDA     DP Indirect Long Indexed,Y     2       6 | 1,2
   B8      CLV     Implied                        1       2 |
   B9      LDA     Absolute Indexed,Y             3       4 | 1,3
   BA      TSX     Implied                        1       2 |
   BB      TYX     Implied                        1       2 |
   BC      LDY     Absolute Indexed,X             3       4 | 3,10
   BD      LDA     Absolute Indexed,X             3       4 | 1,3
   BE      LDX     Absolute Indexed,Y             3       4 | 3,10
   BF      LDA     Absolute Long Indexed,X        4       5 | 1
   C0      CPY     Immediate                      2+      2 | 10
   C1      CMP     DP Indexed Indirect,X          2       6 | 1,2
   C2      REP     Immediate                      2       3 |
   C3      CMP     Stack Relative                 2       4 | 1
   C4      CPY     Direct Page                    2       3 | 2,10
   C5      CMP     Direct Page                    2       3 | 1,2
   C6      DEC     Direct Page                    2       5 | 2,5
   C7      CMP     Direct Page Indirect Long      2       6 | 1,2
   C8      INY     Implied                        1       2 |
   C9      CMP     Immediate                      2*      2 | 1
   CA      DEX     Implied                        1       2 |
   CB      WAI     Implied                        1       3 | 15
   CC      CPY     Absolute                       3       4 | 10
   CD      CMP     Absolute                       3       4 | 1
   CE      DEC     Absolute                       3       6 | 5
   CF      CMP     Absolute Long                  4       5 | 1
   D0      BNE     Program Counter Relative       2       2 | 7,8
   D1      CMP     DP Indirect Indexed,Y          2       5 | 1,2,3
   D2      CMP     Direct Page Indirect           2       5 | 1,2
   D3      CMP     SR Indirect Indexed,Y          2       7 | 1
   D4      PEI     Stack (Direct Page Indirect)   2       6 | 2
   D5      CMP     Direct Page Indexed,X          2       4 | 1,2
   D6      DEC     Direct Page Indexed,X          2       6 | 2,5
   D7      CMP     DP Indirect Long Indexed,Y     2       6 | 1,2
   D8      CLD     Implied                        1       2 |
   D9      CMP     Absolute Indexed,Y             3       4 | 1,3
   DA      PHX     Stack (Push)                   1       3 | 10
   DB      STP     Implied                        1       3 | 14
   DC      JMP     Absolute Indirect Long         3       6 |
   DD      CMP     Absolute Indexed,X             3       4 | 1,3
   DE      DEC     Absolute Indexed,X             3       7 | 5,6
   DF      CMP     Absolute Long Indexed,X        4       5 | 1
   E0      CPX     Immediate                      2+      2 | 10
   E1      SBC     DP Indexed Indirect,X          2       6 | 1,2,4
   E2      SEP     Immediate                      2       3 |
   E3      SBC     Stack Relative                 2       4 | 1,4
   E4      CPX     Direct Page                    2       3 | 2,10
   E5      SBC     Direct Page                    2       3 | 1,2,4
   E6      INC     Direct Page                    2       5 |
   E7      SBC     Direct Page Indirect Long      2       6 | 1,2,4
   E8      INX     Implied                        1       2 |
   E9      SBC     Immediate                      2*      2 |
   EA      NOP     Implied                        1       2 |
   EB      XBA     Implied                        1       3 |
   EC      CPX     Absolute                       3       4 | 10
   ED      SBC     Absolute                       3       4 | 1,4
   EE      INC     Absolute                       3       6 | 5
   EF      SBC     Absolute Long                  4       5 | 1,4
   F0      BEQ     Program Counter Relative       2       2 | 7,8
   F1      SBC     DP Indirect Indexed,Y          2       5 | 1,2,3,4
   F2      SBC     Direct Page Indirect           2       5 | 1,2,4
   F3      SBC     SR Indirect Indexed,Y          2       7 | 1,4
   F4      PEA     Stack (Absolute)               3       5 |
   F5      SBC     Direct Page Indexed,X          2       4 | 1,2,4
   F6      INC     Direct Page Indexed,X          2       6 | 2,5
   F7      SBC     DP Indirect Long Indexed,Y     2       6 | 1,2,4
   F8      SED     Implied                        1       2 |
   F9      SBC     Absolute Indexed,Y             3       4 | 1,3,4
   FA      PLX     Stack (Pull)                   1       4 | 10
   FB      XCE     Implied                        1       2 |
   FC      JSR     Absolute Indexed Indirect      3       8 |
   FD      SBC     Absolute Indexed,X             3       4 | 1,3,4
   FE      INC     Absolute Indexed,X             3       7 | 5,6
   FF      SBC     Absolute Long Indexed,X        4       5 | 1,4
=====================================================================

*  Add 1 if m=0 (16 bit memory/accumulator).
** Opcode is 1 byte, but program counter value pushed onto stack is
   incremented by 2 allowing for optional signature byte.
+  Add 1 byte if x=0 (16-bit index registers).
1  Add 1 cycle if m=0 (16-bit memory/accumulator).
2  Add 1 cycle if low bye of Direct Page (zero page) register
   is other than zero (DL<>0).
3  Add 1 cycle if adding index crosses a page boundary.
4  Add 1 cycle if CPU is 65C02 and d=1 (decimal mode. 65C02 only).
5  Add 2 cycles if m=0 (16-bit memory/accumulator).
6  Subtract 1 cycle if CPU is 65C02 and no page boundary crossed.
7  Add 1 cycle if branch is taken.
8  Add 1 more cycle if branch taken crosses page boundary on 6502,
   65C02, or 65816/65082's emulation mode (e=1).
9  Add 1 cycle for 65802/65816 native mode (e=0).
10 Add 1 cycle if x=0 (16-bit index registers).
11 Add 1 cycle if CPU is 65C02.
12 6502: if low byte of operand is $FF (ie. operand is $xxFF): yields
   incorrect result.
13 7 cycles per byte moved.
14 Uses 3 cycles to shut the processor down; additional cycles are
   required by reset to restart CPU.
15 Uses 3 cycles to shut the processor down; additional cycles are
   required by interrupt to restart it.
16 Byte and cycle counts subject to change in future processors which
   expand WDM into 2-byte opcode portions of instructions of varying
   lengths.

TOC

  ------------------------------------------------------------------------

========================================================================
  ------------------------------------------------------------------------

=====================
Appendix C: IC Pinouts
=====================

           /=============\                     /=============\
       VP  I1          40I RES            Vss  I1          40I RES
      RDY  I2          39I VDA            RDY  I2          39I o2 (OUT)
    ABORT  I3          38I M/X       o1 (OUT)  I3          38I SO
      IRQ  I4          37I o2 (IN)        IRQ  I4          37I o2 (IN)
       ML  I5          36I BE              NC  I5          36I NC
      NMI  I6          35I E              NMI  I6          35I NC
      VPA  I7          34I R/W           SYNC  I7          34I R/W
      VDD  I8          33I D0/BA0         Vdd  I8          33I D0
       A0  I9  W65C816 32I D1/BA1          A0  I9   6502   32I D1
       A1  I10         31I D2/BA2          A1  I10         31I D2
       A2  I11         30I D3/BA3          A2  I11         30I D3
       A3  I12         29I D4/BA4          A3  I12         29I D4
       A4  I13         28I D5/BA5          A4  I13         28I D5
       A5  I14         27I D6/BA6          A5  I14         27I D6
       A6  I15         26I D7/BA7          A6  I15         26I D7
       A7  I16         25I A15             A7  I16         25I A15
       A8  I17         24I A14             A8  I17         24I A14
       A9  I18         23I A13             A9  I18         23I A13
      A10  I19         22I A12            A10  I19         22I A12
      A11  I20         21I Vss            A11  I20         21I Vss
           \=============/                     \=============/

Notes:
   ML: Memory Lock line (pin 5) is asserted low during the execution of
       the read-modify-write (asl,dec,inc,lsr,rol,ror,trb, and tsb
       instructions to inform other ics that the bus may not be claimed
       yet.

   VP: Vector Pull is asserted whenever any of the hardware vector
       address's are being accessed during an IRQ.

 Abort:  An input.  When asserted caused the current instruction to be
         aborted.

   VPA/VDA.  Valid Program Address and Valid Data Address.  These two
             signals extend on the 6502 SYNC line - to better handle
             DMA schemes.

       VPA   VDA
        0     0  -Internal Operation
        0     1  -Valid program address
        1     0  -Valid data address
        1     1  -Opcode fetch

    M/X: Memory and Index lines.  These signals are multiplexed on pin
         38.  M is available during phase zero and X during Phase one.
         These two signals reflect the contents of the status register
         m and x flags, allowing other devices to decode opcode fetches.

    E: Emulation pin.  This signal reflects the state of the processors
       emulation bit (E).

TOC

  ------------------------------------------------------------------------

===================================================================
44 PIN PLCC Pinout.

                    A
                    B
                    O               R           0
            M   I   R   R   V   V   E   V   M   2
            L   R   T   D   P   S   S   D   /   I   B
            B   Q   B   Y   B   S   B   A   X   N   E
           /----I---I---I---I---I---I---I---I---I---I-\
          / 6   5   4   3   2  1  44  43  42  41  40 I
    NMIB I 7                                       39 - E
     VPA I 8                                       38 - R/WB
     VDD I 9                                       37 - VDD
      A0 I 10                                      36 - D0/BA0
      A1 I 11                                      35 - D1/BA1
     VSS I 12               W65C816S               34 - D2/BA2
      A2 I 13                                      33 - D3/BA3
      A3 I 14                                      32 - D4/BA4
      A4 I 15                                      31 - D5/BA5
      A5 I 16                                      30 - D6/BA6
      A6 I 17                                      29 - D7/BA7
         I 18  19  20  21  22  23  24  25  26  27  28 I
         \--l---l---l---l---l---l---l---l---l---l---l-/
            A   A   A   A   A   V   V   A   A   A   A
            7   8   9   1   1   S   S   1   1   1   1
                        0   1   S   S   2   3   4   5

                   44 pin W65C816S PLCC Pinout


TOC

           -----------------------------------------------------

          Send Email

Last updated on: Tuesday, 23-Dec-1997 23:51:46 CST 92
